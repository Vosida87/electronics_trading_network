# electronics_trading_network  
Тестовое задание по созданию веб-приложения "Торговая сеть по продаже электроники", с API интерфейсом и админ-панелью с помощью Python, Django, DRF, PostgreSQL.  
***
## `Описание задачи`  
### Технические требования:
- Python 3.8+  
- Django 3+  
- DRF 3.10+  
- PostgreSQL 10+  

### Задание
Создайте веб-приложение, с API интерфейсом и админ-панелью.  
Создайте базу данных используя миграции Django.  

#### 1. Необходимо реализовать модель сети по продаже электроники. 
Сеть должна представлять собой иерархическую структуру из 3 уровней:  
- Завод;  
- Розничная сеть;  
- Индивидуальный предприниматель.

Каждое звено сети ссылается только на одного поставщика оборудования (не обязательно предыдущего по иерархии). Важно отметить, что уровень иерархии определяется не названием звена, а отношением к остальным элементам сети, т.е. завод всегда находится на 0 уровне, а если розничная сеть относится напрямую к заводу, минуя остальные звенья - её уровень - 1.  

#### 2. Каждое звено сети должно обладать следующими элементами:
- Название;
- Контакты:
* Email;
* Страна;
* Город;
* Улица;
* Номер дома;
- Продукты:
* Название;
* Модель;
* Дата выхода продукта на рынок;
- Поставщик (предыдущий по иерархии объект сети);
- Задолженность перед поставщиком в денежном выражении с точностью до копеек;
- Время создания (заполняется автоматически при создании).

#### 3. Сделать вывод в админ-панели созданных объектов
На странице объекта сети добавить:
- ссылку на «Поставщика»;
- фильтр по названию города;
- «admin action», очищающий задолженность перед поставщиком у выбранных объектов.

#### 4. Используя DRF, создать набор представлений:
- CRUD для модели поставщика (запретить обновление через API поля «Задолженность перед поставщиком»);
- Добавить возможность фильтрации объектов по определенной стране.

#### 5. Настроить права доступа к API так, чтобы только активные сотрудники имели доступ к API.
***
## `Настройки для запуска`

#### Необходимо создать и активировать виртуальное окружение:  
`python -m venv venv`  
`venv/scripts/activate`  
  
#### Далее нужно установить все зависимости проекта:  
`pip install -r requirements`  

#### Создать БД в PostgreSQL:
`psql -U postgres`  # Подключаемся к базе данных PostgreSQL (postgres - пользователь)  
`Далее вводим паролль`  
`CREATE DATABASE <ИМЯ ВАШЕЙ БД>;`  
`\q`  

#### Создать и настроить .env файл со следующими параметрами:  
#Инфа для доступа к базе данных  
`DB_ENGINE='django.db.backends.postgresql'`  
`DB_NAME='НАЗВАНИЕ ВАШЕЙ БД'`  
`DB_USER='postgres'`  
`DB_PASSWORD='ВАШ ПАРОЛЬ'`  
`HOST='ХОСТ'`  
  
#django secret key  
`SECRET_KEY='ВАШ КЛЮЧ'`  

#### Выполнить миграции:
`python manage.py makemigrations`  
`python manage.py migrate`  

#### Создание суперпользователя для входа в админ-панель:
`python manage.py createsuperuser`  

#### Запуск проекта:
`python manage.py runserver`  
***
## `Отчёт с пояснениями по выполнению`  

### 1 пункт - Иерархическая структура.
При создании модели было использовано PARTICIPANT_TYPES для выбора типа участника при создании экземпляра объекта, выбор соответстванно состоял из:  
- Завод;  
- Розничная сеть;  
- Индивидуальный предприниматель.
***
Далее создан метод `clean()` для проверки того, что только завод может иметь уровень в иерархии равный нулю и только нулю.  
***
Также рализована логика автоматического вычисления уровня в методе `save()` в зависимости от количества поставщиков до созданного участника.  
***
Для проверки функционала методов были написаны тесты в electronics_trade/tests/test_participant.py  
Команда запуска всех тестов: `python manage.py test`  

### 2 пункт - Элементы звеньев (участников) в сети.
Для реализации были использованы модели django, всего соотвественно 3 модели:
- Участник сети;
- Контакты участника;
- Продукты участника.
***
Создание отдельной модели участника для каждого типа участника не является рациональным, так как в данном случае будет написано много ненужного кода. Если участники не содержат уникальных атрибутов помимо контактов и продуктов, то разумнее будет использовать одну общую модель участника, а затем использовать связи для связывания контактов и продуктов с участником.
***
Модель контактов может иметь `OneToOneField` связь с моделью участника, чтобы обеспечить привязку одних контактов к одному участнику и наоборот. Это означает, что каждый участник будет иметь только одну связанную модель контактов.
***
Связь продуктов с участником может быть установлена с использованием `ForeignKey`, чтобы позволить создание нескольких продуктов для одного участника. Это означает, что каждый продукт будет иметь связь с одним участником, но участник может иметь несколько связанных продуктов.  

### 3 пункт - Добавление функциональности панели администратора.  
Для добавления ссылки поставщика участника на странице участника в админке использовалась django функция format_html в django.utils.html
***
Для добавления фильтрации по городам на странице участников в админке использовался класс который наследуется от admin.ModelAdmin, он нужен для определения настроек и предоставляет множество своих параметров, среди них и есть list_filter
***
Для добавления admin action была создана функция clear_debt_to_supplier в ParticipantAdmin(admin.ModelAdmin), которая редактирует поле задолженности
***
Дополнительно была реализована фильтрация по тому есть ли задолженность у участника благодоря классу HasDebtFilter который наследуется от admin.SimpleListFilter, который, в свою очередь предлагает настройку своих фильтров
