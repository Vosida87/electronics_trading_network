# `electronics_trading_network`  
Тестовое задание по созданию веб-приложения "Торговая сеть по продаже электроники", с API интерфейсом и админ-панелью с помощью Python, Django, DRF, PostgreSQL.  
***
## `Описание задачи`  
### Технические требования:
- Python 3.8+  
- Django 3+  
- DRF 3.10+  
- PostgreSQL 10+  

### Задание
Создайте веб-приложение, с API интерфейсом и админ-панелью.  
Создайте базу данных используя миграции Django.  

#### 1. Необходимо реализовать модель сети по продаже электроники. 
Сеть должна представлять собой иерархическую структуру из 3 уровней:  
- Завод;  
- Розничная сеть;  
- Индивидуальный предприниматель.

Каждое звено сети ссылается только на одного поставщика оборудования (не обязательно предыдущего по иерархии). Важно отметить, что уровень иерархии определяется не названием звена, а отношением к остальным элементам сети, т.е. завод всегда находится на 0 уровне, а если розничная сеть относится напрямую к заводу, минуя остальные звенья - её уровень - 1.  

#### 2. Каждое звено сети должно обладать следующими элементами:
- Название;
- Контакты:
* Email;
* Страна;
* Город;
* Улица;
* Номер дома;
- Продукты:
* Название;
* Модель;
* Дата выхода продукта на рынок;
- Поставщик (предыдущий по иерархии объект сети);
- Задолженность перед поставщиком в денежном выражении с точностью до копеек;
- Время создания (заполняется автоматически при создании).

#### 3. Сделать вывод в админ-панели созданных объектов
На странице объекта сети добавить:
- ссылку на «Поставщика»;
- фильтр по названию города;
- «admin action», очищающий задолженность перед поставщиком у выбранных объектов.

#### 4. Используя DRF, создать набор представлений:
- CRUD для модели поставщика (запретить обновление через API поля «Задолженность перед поставщиком»);
- Добавить возможность фильтрации объектов по определенной стране.

#### 5. Настроить права доступа к API так, чтобы только активные сотрудники имели доступ к API.
***
## `Настройки для запуска`

#### Необходимо создать и активировать виртуальное окружение:  
`python -m venv venv`  
`venv/scripts/activate`  
  
#### Далее нужно установить все зависимости проекта:  
`pip install -r requirements`  

#### Создать БД в PostgreSQL:
`psql -U postgres`  # Подключаемся к базе данных PostgreSQL (postgres - пользователь)  
`Далее вводим паролль`  
`CREATE DATABASE <ИМЯ ВАШЕЙ БД>;`  
`\q`  

#### Создать и настроить .env файл со следующими параметрами:  
#Инфа для доступа к базе данных  
`DB_ENGINE='django.db.backends.postgresql'`  
`DB_NAME='НАЗВАНИЕ ВАШЕЙ БД'`  
`DB_USER='postgres'`  
`DB_PASSWORD='ВАШ ПАРОЛЬ'`  
`HOST='ХОСТ'`  
  
#django secret key  
`SECRET_KEY='ВАШ КЛЮЧ'`  

#### Выполнить миграции:
`python manage.py makemigrations`  
`python manage.py migrate`  

#### Создание суперпользователя для входа в админ-панель:
`python manage.py createsuperuser`  

#### Запуск проекта:
`python manage.py runserver`  

#### Запуск тестов и получение отчёта по ним:
`coverage run manage.py test`  
`coverage report -m`  
***
## `Отчёт с пояснениями по выполнению`  

### 1 пункт - Иерархическая структура.
Для создании модели было использовано PARTICIPANT_TYPES для выбора типа участника при создании экземпляра объекта, выбор соответстванно состоял из:  
- Завод;  
- Розничная сеть;  
- Индивидуальный предприниматель.
***
Для проверки, что только у завода может быть уровень иерархии, равный нулю, был создан метод `clean()`. Он гарантирует, что уровень участника будет равен нулю только для типа "Завод".  
***
Также в методе `save()` реализована логика для автоматического вычисления уровня участника в зависимости от количества поставщиков, связанных с участником.  
***
Для проверки функциональности этих методов были написаны тесты в файле `electronics_trade/tests/test_participant.py`. Вы можете запустить все тесты с помощью команды `python manage.py test`.  

### 2 пункт - Элементы звеньев (участников) в сети.
Для реализации были использованы три модели Django:
- Участник сети;
- Контакты участника;
- Продукты участника.
***
Создание отдельной модели участника для каждого типа участника не является рациональным, так как в этом случае придется написать много ненужного кода. Если участники не имеют уникальных атрибутов, помимо контактов и продуктов, то разумнее использовать одну общую модель участника и устанавливать связи для связывания контактов и продуктов с участником.
***
Модель "Контакты участника" может иметь связь `OneToOneField` с моделью "Участник сети", чтобы обеспечить привязку одних контактов к одному участнику и наоборот. Это означает, что каждый участник будет иметь только одну связанную модель контактов.
***
Связь между моделью "Продукты участника" и "Участником сети" может быть установлена с использованием `ForeignKey`, чтобы позволить создание нескольких продуктов для одного участника. Итак, каждый продукт будет иметь связь с одним участником, но участник может иметь несколько связанных продуктов.  

### 3 пункт - Добавление функциональности панели администратора.  
Для добавления ссылки на странице участника в админке, была использована django функция `format_html` из модуля `django.utils.html`. Эта функция позволяет форматировать HTML код.
***
Для добавления фильтрации по городам на странице участников в админке, был создан класс, который наследуется от `admin.ModelAdmin`. Этот класс определяет настройки и предоставляет множество параметров, в том числе `list_filter`, который позволяет добавить фильтр по указанному полю.
***
Для добавления admin action была создана функция `clear_debt_to_supplier` в классе `ParticipantAdmin(admin.ModelAdmin)`, которая редактирует поле задолженности. admin action представляет собой действие, которое можно выполнить над выбранными объектами в админке.
***
**_Дополнительно_** была реализована фильтрация по наличию задолженности у участника благодаря классу `HasDebtFilter`, который наследуется от `admin.SimpleListFilter`. Этот класс предоставляет возможность настройки фильтров.  
**_Дополнительно_** были добавлены тесты для проверки работоспособности нового функционала.

### 4 пункт - CRUD + фильтрация и сортировка. 
Для создания `API CRUD (Create, Read, Update, Delete)` был использован модуль `rest_framework` и его класс `viewsets.ModelViewSet`. Этот класс предоставляет готовые методы для выполнения операций `CRUD` над моделью. 
***  
Для выполнения фильтрации и сортировки был использован модуль `django_filters`. Этот модуль позволяет легко добавлять фильтры и сортировку к представлениям `API`.  

### 5 пункт - Права доступа.
В данном пункте были реализованы права доступа. Исходя из того, что в модели, от которой я наследовал пользователя, присутствует поле `is_active`, было использовано это поле для проверки статуса доступа.  
Для проверки статуса поля `is_active` был использован класс `permissions.BasePermission`. Этот класс позволяет определить свои правила доступа и проверять их. Потом это ограничение было добавлено в `API` представления.
Также были написаны тесты для проверки ограничений доступа.  
***
### Coverage 99%
Уровень покрытия кода тестами составляет 99%. Почти все части кода были протестированы и проверены на работоспособность.  
